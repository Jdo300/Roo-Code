# Design Document: Roo Code IPC MCP Server

## 1. Introduction

**Purpose:** Create a standalone Node.js MCP (Model Context Protocol) server that wraps the Roo Code extension's existing IPC (Inter-Process Communication) API.

**Goal:** Expose Roo Code IPC commands as MCP tools and provide mechanisms for clients to access asynchronous `TaskEvent`s generated by the Roo Code extension.

## 2. Project Setup & Structure

- **Location:** `C:\Users\Jason\AppData\Roaming\Roo-Code\MCP\roo-ipc-mcp-server` (Standard MCP server location for this environment).
- **Language:** TypeScript.
- **Initialization:** Use `npx @modelcontextprotocol/create-server roo-ipc-mcp-server` within the MCP directory.
- **Key Dependencies:**
    - `@modelcontextprotocol/sdk`: For MCP server implementation.
    - `node-ipc`: For connecting to the Roo Code IPC server.
    - `zod`: For internal validation of tool inputs/outputs.
- **Build Process:** Standard `npm run build` (using `tsc`).
- **Internal Structure:**
    ```
    roo-ipc-mcp-server/
    ├── src/
    │   ├── index.ts          # Main server entry point, MCP server setup
    │   ├── ipc-client.ts     # Class/module managing connection to Roo Code IPC
    │   ├── tool-handlers.ts  # Logic for handling tools/call requests
    │   ├── event-handler.ts  # Logic for receiving IPC TaskEvents and buffering
    │   └── schemas.ts        # Zod schemas for tool inputs/outputs
    ├── build/                # Compiled JavaScript output
    ├── package.json
    └── tsconfig.json
    ```

## 3. Core Server Logic

- The server will implement the MCP protocol using `@modelcontextprotocol/sdk/server`.
- It will use the `StdioServerTransport` for communication with the Roo Code extension (which acts as the MCP client manager).
- On startup, the server initializes an internal `ipc-client` (based on [`rpc-tcp-test/ipc-client.cjs`](rpc-tcp-test/ipc-client.cjs:0)) to connect to the Roo Code IPC server (default: `localhost:7800`, potentially configurable via environment variables passed in `mcp_settings.json`).
- The server manages the lifecycle of the connection to the Roo Code IPC server (connect, disconnect, errors).
- The internal `ipc-client` listens for all `TaskEvent` messages emitted by the Roo Code IPC server.

## 4. MCP Tool Definitions

- **Naming Convention:** All tools will be prefixed with `roo_ipc_` (e.g., `roo_ipc_start_task`).
- **Mapping:** Each relevant `TaskCommandName` from [`src/schemas/ipc.ts`](src/schemas/ipc.ts:22) will be mapped to a corresponding MCP tool.
- **Descriptions:** Tool descriptions will clearly state their purpose and map to the underlying IPC command. Known issues or limitations of the underlying IPC command (from [`cline_docs/activeContext.md`](cline_docs/activeContext.md:0)) should be noted initially.
- **Input Schemas:** JSON Schemas will be defined for each tool's input, based on the `data` property of the corresponding `TaskCommand` Zod schema in [`src/schemas/ipc.ts`](src/schemas/ipc.ts:52). Zod will be used internally for validation.
- **Output:** Successful tool calls will return the `payload` from the corresponding `commandResponse` `TaskEvent` received from the IPC server. Errors will be returned as `McpError` objects.
- **Polling Tools:**
    - **`roo_ipc_poll_ai_messages`**:
        - **Input Schema:** `{ "type": "object", "properties": { "limit": { "type": "integer", "minimum": 1, "default": 1 } } }`
        - **Description:** Polls for buffered AI message events (`TaskEvent` where `eventName` is `Message`). Retrieves up to `limit` events (default 1) and removes them from the queue. Indicates if the last retrieved message is incomplete.
        - **Output:** `{ "events": [...], "isPartial": boolean }`. `events` contains an array of `Message` `TaskEvent` objects. `isPartial` is true if the last event represents an incomplete AI response chunk.
    - **`roo_ipc_poll_other_events`**:
        - **Input Schema:** `{ "type": "object", "properties": { "limit": { "type": "integer", "minimum": 1, "default": 1 } } }`
        - **Description:** Polls for buffered non-AI message events (`TaskEvent`s for all types _except_ `Message`). Retrieves up to `limit` events (default 1) and removes them from the queue.
        - **Output:** `{ "events": [...] }`. `events` contains an array of non-`Message` `TaskEvent` objects.

## 5. Handling Asynchronous `TaskEvent`s (Dual Approach)

This server will support two methods for clients to receive asynchronous `TaskEvent`s originating from the Roo Code IPC connection:

1.  **Polling (Primary for Roo Code Client):**
    - The internal `ipc-client` receives all `TaskEvent`s.
    - Two separate internal queues/buffers will be maintained: one for `Message` events and one for all other event types. Size limits should be implemented to prevent excessive memory usage.
    - The `roo_ipc_poll_ai_messages` tool retrieves up to `limit` events from the AI message queue. It determines the `isPartial` flag by inspecting the payload of the _last_ event retrieved (requires the IPC `Message` event payload to indicate completion status). The retrieved events are removed (popped) from the queue.
    - The `roo_ipc_poll_other_events` tool retrieves up to `limit` events from the "other events" queue and removes (pops) them.
2.  **Push Notifications (Best Effort / Future Clients):**
    - Whenever _any_ `TaskEvent` is received from the IPC connection, the MCP server will _attempt_ to push a generic MCP notification to all connected clients.
    - The notification format could be: `{ type: "notification", name: "rooIpcEventReceived", data: <Full TaskEvent Object> }`.
    - Implementation depends on the `@modelcontextprotocol/sdk/server` supporting server-initiated notifications via the `StdioServerTransport`. If the SDK doesn't directly support this for stdio, this part might be omitted or require further investigation.
    - Clients like the current Roo Code `McpHub` are expected to ignore these unsolicited notifications and rely solely on the polling tools.

## 6. Error Handling

- **IPC Connection Errors:** If the connection to the Roo Code IPC server fails or drops, the MCP server should log the error. Its status might be reflected via MCP mechanisms if available, or it might simply fail subsequent tool calls until reconnected.
- **IPC Command Errors:** Errors returned within a `commandResponse` `TaskEvent` payload (e.g., `{ error: { message: "..." } }`) will be translated into an `McpError` (e.g., `ErrorCode.OperationFailed`, `ErrorCode.InvalidParams`) and returned as the result of the corresponding `tools/call`.
- **Tool Input Validation:** Invalid input arguments provided to `tools/call` (validated using Zod against the tool's schema) will result in an `McpError` with `ErrorCode.InvalidParams`.
- **Internal Server Errors:** Unexpected errors within the MCP server itself should result in an `McpError` with `ErrorCode.InternalError`.

## 7. MCP Configuration (`mcp_settings.json` Example)

An entry in the global (`%APPDATA%\Roo-Code\settings\mcp_settings.json`) or project (`.roo/mcp.json`) configuration file:

```json
{
	"mcpServers": {
		"roo-ipc": {
			"command": "node",
			"args": ["C:/Users/Jason/AppData/Roaming/Roo-Code/MCP/roo-ipc-mcp-server/build/index.js"],
			"env": {
				// Optional: e.g., "ROO_IPC_HOST": "127.0.0.1", "ROO_IPC_PORT": "7800"
			},
			"disabled": false,
			"alwaysAllow": [],
			"timeout": 60 // Optional: Default timeout in seconds
		}
		// ... other servers
	}
}
```

## 8. High-Level Implementation Plan

1.  **Phase 1: Setup:**
    - Create the project directory (`C:\Users\Jason\AppData\Roaming\Roo-Code\MCP\roo-ipc-mcp-server`).
    - Initialize the TypeScript project using `npx @modelcontextprotocol/create-server`.
    - Install `node-ipc` and `zod` dependencies.
    - Set up basic MCP server boilerplate in `src/index.ts`.
2.  **Phase 2: IPC Client:**
    - Implement `src/ipc-client.ts` to connect to and manage the Roo Code IPC server connection. Handle connection events (connect, disconnect, error).
    - Implement logic to receive and parse incoming `IpcMessage`s.
3.  **Phase 3: Basic Tools:**
    - Implement `src/tool-handlers.ts`.
    - Implement handlers for a few core tools (e.g., `roo_ipc_is_ready`, `roo_ipc_get_configuration`, `roo_ipc_start_task`).
    - Define corresponding input/output schemas in `src/schemas.ts`.
    - Integrate handlers with the MCP server in `src/index.ts`.
4.  **Phase 4: Event Handling & Polling Tools:**
    - Implement `src/event-handler.ts` to receive `TaskEvent`s from the `ipc-client`.
    - Implement the dual queue/buffer logic (AI Messages vs. Other Events).
    - Implement the `roo_ipc_poll_ai_messages` tool handler, including `limit` (default 1), `isPartial` logic, and popping from the queue.
    - Implement the `roo_ipc_poll_other_events` tool handler, including `limit` (default 1) and popping from the queue.
5.  **Phase 5: Remaining Tools & Push Notifications:**
    - Implement handlers and schemas for all remaining IPC commands mapped to MCP tools.
    - Refine error handling across all tools.
    - Investigate SDK support for server-initiated notifications over stdio. If feasible, implement the best-effort push notification logic in `src/event-handler.ts`.
6.  **Phase 6: Testing & Documentation:**
    - Write unit/integration tests for key components (IPC client connection, tool handlers, event buffering/polling).
    - Add inline documentation (TSDoc).
    - Update project README with setup and usage instructions.
